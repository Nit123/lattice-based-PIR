#include <random>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include "aes.hpp"
#include "prg.hpp"


#define M 1000 // change to 500 for uint64_t version
#define N 500 // change to 250 for uint64_t version
#define p 65535 //(2^16-1)
#define q 4294967296 // (2^32)...
#define ratio q/p



using namespace std;
using namespace LWERandomness;


/*
    INTEGER VERSION OF THE PRF: requires M and N to be smaller 
*/
uint64_t* prf(uint64_t A[N][M], uint64_t x[M]); // main PRF function
void initializeArrays(uint64_t A[N][M]); // initializes random arrays
void initializeArrays(uint64_t x[M]);
uint64_t* testIntegerPRF(); // tester
void key_homomorphic_test();


// /*
//     FLOATING POINT VERSION OF PRF: M and N can be large but requires matrices to be outputted and read to a file
// */
// void initializeArraysIntoFiles(); // Initialize random arrays into files
// double* prf_from_files(); // PRF that reads from files
// void testRealPRF(); // tester

int main(int argc, char *argv[]){
	ofstream myf;
	myf.open("data.txt");
	uint64_t *result;
	for(int i = 0; i < 1000; i++){
		result = testIntegerPRF();
		for(int j = 0; j < N; j++){
			myf << result[j] << "\n";
		}
	}

	myf.close();
    //key_homomorphic_test();
    //testRealPRF();

    return 0;
}

void key_homomorphic_test(){
	auto A_1 = new uint64_t[N][M];
	auto A_2 = new uint64_t[N][M];

	// time to create an addition one
	auto sum_A = new uint64_t[N][M];

	uint64_t *x = new uint64_t[M];

	initializeArrays(A_1);
	initializeArrays(A_2);
	initializeArrays(x);

	// time to add them
	for(int i = 0; i < N; ++i){
		for(int j = 0; j < M; ++j){
			sum_A[i][j] = (A_1[i][j] + A_2[i][j]) % q;
		}
	}


	uint64_t* random_1 = prf(A_1, x);
	uint64_t* random_2 = prf(A_2, x);
	uint64_t* random_sum = prf(sum_A, x);

	//time to check if it's right!
	for(int i = 0; i < N; ++i){
		uint64_t temp = (random_1[i] + random_2[i]) % p;
		if(temp != random_sum[i]){
			cout << "Key homomorphism failed -- F(k1, x) + F(k2, x): " << temp << " F(k1 + k2, x): " << random_sum[i] << endl; 
		}
	}


	return;

}

uint64_t* testIntegerPRF(){
    //uint64_t A[N][M] = {};
    auto A = new uint64_t[N][M];
    uint64_t *x = new uint64_t[M];

    cout << "Initializing arrays" << endl;
    initializeArrays(A);
    initializeArrays(x);
    cout << "Finished initializing arrays" << endl;

    cout << "Beginning prf" << endl;
    uint64_t* randomNum = prf(A, x);
    cout << "end of prf" << endl << endl;

    // for(int i = 0; i < N; i++){
    //     cout << randomNum[i] << " ";
    // }

    return randomNum;
}

// void testRealPRF(){
//     initializeArraysIntoFiles();
//     double *randomNum = prf_from_files();

//      for(int i = 0; i < N; i++){
//         cout << randomNum[i] << " ";
//     }

//     return;
// }

// void initializeArraysIntoFiles(){
//     random_device rd;
//     std::mt19937 gen(rd());
//     uniform_int_distribution<uint64_t> distr(0, q);
//     cout << "Initializing arrays and placing into files" << endl;
//     ofstream A_file, x_file;
//     A_file.open("A.txt");
//     for(int i = 0; i < N; ++i){
//         for(int j = 0; j < M; ++j){
//             A_file << distr(gen) << " ";
//         }

//         A_file << endl;
//     }

//     A_file.close();

//     x_file.open("x.txt");
//     for(int i = 0; i < M; i++){
//         x_file << distr(gen) << " ";
//     }

//     x_file.close();
//     return;
// }

void initializeArrays(uint64_t x[M]){
	byte buffer[16];
    static ifstream urandom("/dev/urandom", std::ios::binary);
    urandom.read(reinterpret_cast<char *>(buffer), 16);
    urandom.close();

    AES_KEY aes_key{};
    AES_128_Key_Expansion(buffer, &aes_key);

    block blk;
    for(int i = 0; i < M; i+=4){
        //x[i] = distr(gen);
        block tmp = blk;
        AES_ecb_encrypt_blk(&blk, &aes_key);
        __int128 num = (__int128) blk;
        uint64_t val0 = 0;
        val0 = val0 | num;
        // val has 64 bits of num
        uint64_t val1 = 0;
        val1 = val0 >> 32; // got MSB represented
        uint64_t val2 = 0;
        val2 = val0 << 32;
        val2 = val2 >> 32; // got LSB represented
        x[i] = val1;
        x[i+1] = val2;


        val0 = 0;
        num = num >> 64;
        val0 = val0 | num;
        // val has 64 bits of num
        val1 = 0;
        val1 = val0 >> 32;// got MSB represented
        val2 = 0;
        val2 = val0 << 32;
        val2 = val2 >> 32; // got LSB represented
        x[i+2] = val1;
        x[i+3] = val2;


        if(x[i] > q){
                cout << "Assigned an invalid element in x[i]: " << x[i] << endl;
        }
        else if(x[i+1] > q){
            cout << "Assigned an invalid element in x[i+1]: " << x[i+1] << endl;
        }
        else if(x[i+2] > q){
            cout << "Assigned an invalid element in x[i+2]: " << x[i+2] << endl;
        }
         else if(x[i+3] > q){
            cout << "Assigned an invalid element in x[i+3]: " << x[i+3] << endl;
        }

        blk = tmp + 1;
    }
}

void initializeArrays(uint64_t A[N][M]){
    // random_device rd;
    // std::mt19937 gen(rd());
    // uniform_int_distribution<uint64_t> distr(0, q);
    byte buffer[16];
    static ifstream urandom("/dev/urandom", std::ios::binary);
    urandom.read(reinterpret_cast<char *>(buffer), 16);
    urandom.close();

    AES_KEY aes_key{};
    AES_128_Key_Expansion(buffer, &aes_key);

    block blk;

    cout << "in Initialize Arrays" << endl;
    for(int i = 0; i < N; i++){
        for(int j = 0; j < M; j+=4){
            //A[i][j] = distr(gen);
            //blk++;
            block tmp = blk;
            AES_ecb_encrypt_blk(&blk, &aes_key);
            __int128 num = (__int128) blk;
            uint64_t val0 = 0;
            val0 = val0 | num;
            uint64_t val1 = 0;
            val1 = val0 >> 32; //got MSB represented
            uint64_t val2 = 0;
            val2 = val0 << 32;
            val2 = val2 >> 32; //got LSB represented
            A[i][j] = val1;
            A[i][j+1] = val2;

            //cout << "A[i][j]: " << A[i][j] << endl;
            //cout << "A[i][j+1]: " << A[i][j+1] << endl;
            
            val0 = 0;
            num = num >> 64;
            val0 = val0 | num;
            val1 = 0;
            val2 = 0;
            val1 = val0 >> 32; // got MSB represented
            val2 = val0 << 32;
            val2 = val2 >> 32; // got LSB reprsented
            A[i][j+2] = val1;
            A[i][j+3] = val2;

            //cout << "A[i][j+2]: " <<A[i][j+2] << endl;
            //cout << "A[i][j+3]: " << A[i][j+3] << endl;


            if(A[i][j] > q){
                cout << "Assigned an invalid element in A[i][j]: " << A[i][j] << endl;
            }
            else if(A[i][j+1] > q){
                cout << "Assigned an invalid element in A[i][j+1]: " << A[i][j+1] << endl;
            }
            else if(A[i][j+2] > q){
                cout << "Assigned an invalid element in A[i][j+2]: " << A[i][j+2] << endl;
            }
            else if(A[i][j+3] > q){
                cout << "Assigned an invalid element in A[i][j+3]: " << A[i][j+3] << endl;
            }

            blk = tmp + 1;
        }
    }

   
}

// double* prf_from_files(){
//     double x[M] = {};

//     uint64_t temp_val;
//     int i = 0;
//     ifstream x_file;
//     x_file.open("x.txt");
//     while(x_file >> temp_val){
//         x[i] = temp_val;
//         i++;
//     }
//     x_file.close();


//     static double rand[N];
//     //double ratio = q / p;

//     // double temp_product = 0;
//     double row_vector[M] = {};

//     string line;
//     ifstream A_file;
//     int count = 0;
//     int linecount = 0;
//     A_file.open("A.txt");
//     while(A_file){
//         getline(A_file, line);
//         stringstream stream(line);
        
//         uint64_t element;

//         while(stream >> element){
//             row_vector[count] = element;
//             count++;
//         }
//         count = 0;


//         // do the calculation you need for this line
//         for(int i = 0; i < M; i++){
//             rand[linecount] += (row_vector[i] * x[linecount]);
//         }

//         cout << "Start rounding" << endl;
//         // rounding protocol
//         double count2 = 1;
//         while(count2 * ratio < rand[linecount]){
//             count2 *= 2;
//         }

//         rand[linecount] = round((count2-1) * ratio);
//         count2 = 1;

//         linecount++;
//         //count++;
//         cout << "end rounding" << endl;
//     }

//     return rand;
// }

uint64_t* prf(uint64_t A[N][M], uint64_t x[M]){
    //cout << "in PRF" << endl;
    uint64_t *rand = new uint64_t[N];
    //double ratio = q/p;
    uint64_t temp = 0;

    for(int i = 0; i < N; ++i){
        for(int j = 0; j < M; ++j){
            //temp = (temp + ((A[i][j] * x[j]) % q)) % q;
            temp = (temp + (A[i][j] * x[j])) % q;
        }

        // // // rounding to p
        //     // // dumb way: x = rand[i]
        //     // // ratio while loop until we get the answer
            uint64_t count = 1;
            uint64_t multiple = (uint64_t) ratio;

            //cout << "Start rounding" << endl;
            while(count *  multiple < temp && temp != 0){
                count++;
            }
            //cout << "End rounding" << endl;
            // if(temp == 0){
            // 	rand[i] = 0;
            // }
            // else{
            // 	rand[i] = count-1;
            // }

            if(count - 1 == 0){
                //cout << "ratio: " << ratio << "temp: " << temp << endl; 
                rand[i] = count;
            }
            // else if(temp == 0){
            // 	rand[i] = 0;
            // }
            else{
                rand[i] = count-1;
            }
           
           
            count = 1;
            temp = 0;
        // }
    }

    return rand;
}